# WHU-ComputerOrganizationDesign-lab
## 概述
***武汉大学计算机学院 计算机组成原理课程设计攻略***   **riscv版**<br>
<br>
**注：本文是基于2023年春季学期，xxb班的课设写的，其他老师/年份可能有一些地方不一样，如果在2023年春季学期之后看到这篇文章，建议还是仔细阅读一下其中的代码。**<br>
<br>
从2023年春季学期开始，这门课程要求使用Verilog实现三个包括riscv指令集中部分指令的CPU。这三个CPU是单周期CPU，不带冒险检测的流水线CPU和带冒险检测与处理的流水线CPU。<br>
<br>
本仓库中的代码为完整的三个CPU的Verilog代码，附带一个教程和说明以方便读者~~应付~~通过验收时的提问。*（多说几句，这课程设计纯属逆天，还有实验报告按着那个基本框架写都能写到1.5万字以上）*<br>
## 指令集/机器码/汇编程序
这个部分需要具体看老师要求实现什么语句，并且看他是怎么要求编写这些语句的机器码了，比如xxb的要求是Task1中的20条汇编，对应的机器码的编写方法也有他自己的做法。**注意：不同老师大概率不一样，比如我知道的fj班就使用了另一系列指令/机器码，这个写后面的模块大概率会用到，所以不同班很难一起做。**<br>
<br>
其他就没有什么特别好说的，**翻译转换一般需要自己做**，并且确实建议自己来，收别人的翻译转换结果可能会有错，这样会导致后来调试功能的时候难以排查可能出现问题的根因。有时间的话可以阅读他写的汇编程序，理一下具体的流程，有助于查错，（这个仓库的内容应该是完全无误的，如果之后的年份这门课有其他要求，做对应的修改即可）当然要是没时间的话就直接看一下这篇文章的功能描述即可。<br>
<br>
然后先大概说一下如何验收。程序的输出一般有两种：一个就是每句汇编语句的PC地址；一个是程序运行的计算结果。而xxb会要求设置两个频率：一个快的clk频率，（可以马上算出来结果），他会用来直接查看程序运行结果；一个慢clk频率，他使用这个查看PC地址显示。所以其实我们可以得到四种组合：快clk+PC地址，快clk+结果，慢clk+PC地址，慢clk+结果。（当然其中有两个情况没什么价值，但是这里可以说明我们需要两个开关来分别控制频率和输出的内容）拨快/慢clk和PC地址/结果的代码在顶层模块里面，是分别用了一个开关控制的，应该是14号和15号开关（可能有误，这篇文章经过多次修改，笔者也很久没写过Verilog，~~懒得~~难以理解其中的代码了，建议自行到代码中阅读）。<br>
## 单周期CPU
这个部分的总体思路就是先写好每个模块的功能，然后拿一个顶层文件连接起来，对应的原理图在[Task文件夹里面](https://github.com/bryceyin13/WHU-ComputerOrganizationDesign-lab/blob/main/Task/Task2%20SingleCycleCPU.pdf)。其对应的汇编程序是第一个，求1-100的加和，然后放到r31显示，快clk显示的结果就是13ba（16进制的5050），慢clk结果先是0，**过一段时间之后显示13ba**。老师验收时可能会看这个过程中PC地址的变化，因为是单周期，PC地址变化先开始是前面循环（加和），最后PC地址会停在最后一条指令的位置，**也就是9**（直接拨快clk只能看到9，因为前面PC地址的变化闪的太快，无法看到具体的变化）。
## 基本的流水线CPU
基本流水线CPU是在单周期的基础上加了流水线寄存器的模块。原理图也在Task里面。这个部分对应的汇编程序是一个冒泡排序，很长，我也~~懒得看~~没完全看懂，大概流程是先对内存模块（DMem）里面的数组（RAM，模拟的就是内存的存储块）的0-9号位置先初始化成10-1，然后排序成1-10再输出。具体冒泡的细节就要去看他的汇编代码了，**输出的计算结果是一个1-a的递增序列，如果直接拨快频率的话就只能看到a，所以建议拨慢频率看变化过程。** <br>
<br>
关于PC地址，在前面来会来回循环排序，最后会循环显示4个地址，没记错的话是78，79，80，81（16进制下，也就是数码管会显示4e，4f，50，51），是因为这个实验里CPU输出的PC地址是直接输出Imem那里的地址，但是他停止等待的汇编程序是用一个beq实现的（if 0==0，跳转回自己），在MEM级决定是不是跳转并且修改PC地址，所以放入IMem（对应大二上学的计组课这个模块是在IF级）的指令地址就是beq，beq下一条，beq下下一条，beq下下下一条（这个地方beq那条指令走到了MEM级，修改了要装入IF级/IMem的PC地址为beq的地址），beq的地址，之后继续循环，所以是这样显示的。**（这里的原理略复杂，笔者解释的也不好，大家有时间最好仔细阅读Verilog代码，没时间的话也不需要搞懂，大概率他验收的时候不问这个，这里笔者验收的时候他只看了计算结果的1-10）**。<br>
<br>
**直接拨快clk看到的PC地址是类似于一个“98”的显示结果，不过仔细看会发现有的数码管会更亮，有的更暗，是因为4e-51这四个数高速循环显示（原因如上一段），亮的地方是这四个数都要亮的数码管，暗的地方是这几个数字中有的要亮，有的不要亮的数码管。**<br>
## 完整的流水线CPU
完整流水线CPU就是在第二个任务的基础上加了**四个检测冒险的模块**，并不复杂。对应的汇编程序是求斐波那契数列，他给的汇编程序里面有几条的顺序需要改一下，具体哪几条又因为笔者羸弱的记忆功能导致没印象，有兴趣探索的话可以到[这个文件里面](https://github.com/bryceyin13/WHU-ComputerOrganizationDesign-lab/blob/main/Final_Pipeline/IMem.v)找到的汇编代码和老师给出的[这个文件](https://github.com/bryceyin13/WHU-ComputerOrganizationDesign-lab/blob/main/Task/Task1%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E4%B8%8E%E9%AA%8C%E8%AF%81%E7%A8%8B%E5%BA%8F%E8%AF%BE%E5%A0%82%E7%94%A8.pdf)里面的第三个程序的汇编代码对照，不过介于老师应该也不会问相关的内容，不看的话应该也是可以的（多说一句，这里不知道是他故意的还是不小心的，反正笔者当时按那个汇编代码在纸上模拟了几遍过程才找出来问题。。。）。**这个程序的计算结果是15（16进制的21），PC地址也是几个值在一直循环，和第二个任务的原理相同，就不多解释了。**
## 结尾
最后留个联系方式，qq2766572117，有问题欢迎大家来问我/对其中的内容进行订正。
